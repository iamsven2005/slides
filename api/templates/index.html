<!doctype html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Realtime Slides</title>
    <style>
        :root {
            --bg: #0b0f1a;
            --panel: #0f1626;
            --ink: #eef2f8;
            --muted: #a9b4c7;
            --accent: #6ea8fe;
            --border: #22304a;
        }

        * { box-sizing: border-box }

        html, body { height: 100% }

        body {
            margin: 0;
            background: var(--bg);
            color: var(--ink);
            font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
        }

        .app {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
        }

        .side {
            border-right: 1px solid var(--border);
            background: var(--panel);
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .side header {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .title {
            background: #0d1322;
            border: 1px solid var(--border);
            color: var(--ink);
            border-radius: 10px;
            padding: 6px 10px;
            outline: none;
            width: 100%;
            font-weight: 600;
        }

        .slides {
            overflow: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slide-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            border: 1px solid var(--border);
            background: #0d1322;
            border-radius: 12px;
            cursor: grab;
            user-select: none;
        }
        .slide-item:active { cursor: grabbing; }

        .slide-item.active { outline: 2px solid var(--accent); }

        .slide-item.drag-over { outline: 2px dashed var(--accent); }

        .slide-item .n {
            width: 26px;
            height: 26px;
            border-radius: 8px;
            background: #121a2d;
            display: grid;
            place-items: center;
            color: var(--muted);
            font-size: 12px;
            flex: 0 0 auto;
        }

        .slide-item input {
            flex: 1;
            background: transparent;
            border: none;
            color: var(--ink);
            font-weight: 600;
            outline: none;
            min-width: 0;
        }

        .btn {
            border: 1px solid var(--border);
            background: #0d1322;
            color: var(--ink);
            padding: 8px 10px;
            border-radius: 10px;
            cursor: pointer;
        }
        .btn:hover { background: #121a2d; }
        .btn:disabled { opacity: .5; cursor: not-allowed; }

        .grow { flex: 1 }

        .main {
            display: grid;
            grid-template-rows: 52px 1fr 40px;
            height: 100vh;
            min-width: 0;
        }

        .toolbar {
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--panel);
            flex-wrap: wrap;
        }

        .toolbar .right {
            margin-left: auto;
            color: var(--muted);
            font-size: 12px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .stage-wrap {
            overflow: auto;
            display: grid;
            place-items: center;
            padding: 16px;
        }

        .stage {
            width: 960px;
            height: 540px;
            background: white;
            color: #111;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            position: relative;
            overflow: hidden;
            display: block;
            user-select: none;
        }

        .obj { position: absolute; }
        .obj.selected { outline: 2px solid rgba(110, 168, 254, .9); outline-offset: 0; }
        .obj.selected { cursor: move; }

        .handle { box-shadow: 0 0 0 2px rgba(110, 168, 254, .9); background: #fff; }

        .marquee {
            position: absolute;
            border: 1px dashed #6ea8fe;
            background: rgba(110, 168, 254, .15);
            pointer-events: none;
        }

        .footer {
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: var(--panel);
            color: var(--muted);
            font-size: 12px;
        }

        /* inputs */
        .small {
            height: 32px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: #0d1322;
            color: var(--ink);
            outline: none;
        }

        .label { color: var(--muted); font-size: 12px; }

        /* Fullscreen presentation keeps 960Ã—540 and scales to fit */
        .stage.presenting {
            position: fixed;
            left: 50%;
            top: 50%;
            width: 960px;
            height: 540px;
            border-radius: 0;
            box-shadow: none;
            transform-origin: center center;
            z-index: 9999;
        }

        /* Small helper for the toolbar buttons */
        .group { display: inline-flex; gap: 6px; align-items: center; }
    
        .hamburger {
            font-size: 20px;
            cursor: pointer;
            background: none;
            border: none;
            color: var(--ink);
            margin-right: 8px;
        }
        .side.collapsed {
            width: 0;
            min-width: 0;
            overflow: hidden;
        }
        .app.collapsed {
            grid-template-columns: 0 1fr;
        }

</style>
</head>

<body>
    <div class="app">
        <aside class="side">
            <header>
                <input id="deckTitle" class="title" value="Untitled deck" />
            </header>
            <div class="slides" id="slides"></div>
            <div style="padding:12px; display:flex; gap:8px; flex-wrap:wrap">
                <button class="btn" id="addSlide">+ Add</button>
                <button class="btn" id="delSlide">Delete</button>
                <button class="btn" id="dupe">Duplicate</button>
                <button class="btn" id="presentBtn">Present</button>
            </div>
        </aside>

        <main class="main">
            <div class="toolbar"><button id="hamburger" class="hamburger">â˜°</button>
                <button id="tool-select" class="btn">Select</button>
                <button id="tool-rect" class="btn">Rect</button>
                <button id="tool-ellipse" class="btn">Ellipse</button>
                <button id="tool-text" class="btn">Text</button>

                <span class="label">BG</span>
                <input id="bg-color" type="color" class="small" />

                <span class="label">Color</span>
                <input id="color" type="color" class="small" value="#111111" />

                <span class="label">Font size</span>
                <input id="fontSize" type="number" class="small" min="8" max="200" step="1" value="32" style="width:80px" />

                <span class="label">Align</span>
                <div class="group">
                    <button class="btn" id="alignLeft">Left</button>
                    <button class="btn" id="alignCenter">Center</button>
                    <button class="btn" id="alignRight">Right</button>
                </div>

                <div class="right">
                    <div class="group">
                        <button class="btn" id="undoBtn" title="Undo (Ctrl/Cmd+Z)">Undo</button>
                        <button class="btn" id="redoBtn" title="Redo (Ctrl/Cmd+Shift+Z / Ctrl+Y)">Redo</button>
                    </div>
                    <span id="saveState">Saved</span>
                </div>
            </div>

            <div class="stage-wrap">
                <div class="stage" id="stage"></div>
            </div>
            <div class="footer">
                <span>Share this URL to collaborate: <code id="url"></code></span>
            </div>
        </main>
    </div>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js" crossorigin="anonymous"></script>
    <script>
        // ---------------------- Utilities ----------------------
        const $ = (s, r = document) => r.querySelector(s);
        const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));
        const uuidv4 = () => ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c => (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16));
        const debounce = (fn, ms = 400) => { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); } };
        const deckId = new URL(location.href).searchParams.get('deck');
        $('#url').textContent = location.href;

        // ---------------------- Client State ----------------------
        let deck = { id: deckId, title: 'Untitled deck', slides: [] };
        let currentIndex = 0;
        let isApplyingRemote = false;
        let serverVersion = 0;
        let selection = [];
        let dragState = null;
        let creatingObj = null;
        let marquee = null;
        let lastMouse = { x: 200, y: 150 }; // for paste positioning

        // Undo/Redo history
        let history = [], historyIndex = -1;
        const MAX_HISTORY = 100;
        const clone = (x) => JSON.parse(JSON.stringify(x));
        function pushHistory() {
            if (isApplyingRemote) return;
            const snap = clone(deck);
            const prev = history[historyIndex];
            if (prev && JSON.stringify(prev) === JSON.stringify(snap)) return;
            history = history.slice(0, historyIndex + 1);
            history.push(snap);
            if (history.length > MAX_HISTORY) history.shift();
            historyIndex = history.length - 1;
            updateUndoRedoUI();
        }
        function applyState(snap) {
            deck = clone(snap);
            selection = [];
            renderAll();
            postSave();
            updateUndoRedoUI();
        }
        function undo() { if (historyIndex > 0) { historyIndex--; applyState(history[historyIndex]); } }
        function redo() { if (historyIndex < history.length - 1) { historyIndex++; applyState(history[historyIndex]); } }

        function updateUndoRedoUI() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (!undoBtn || !redoBtn) return;
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // In-canvas clipboard fallback
        let appClipboard = null;
        let lastPasteBump = 0; const PASTE_BUMP_STEP = 16;
        const deepClone = x => JSON.parse(JSON.stringify(x));
        const clamp = (v, a, b) => Math.min(b, Math.max(a, v));

        function getSelectedObjects() { return currentSlide().objects.filter(o => selection.includes(o.id)); }
        function asClipboardPayload(objs) { return { type: 'realtime-slides', version: 1, objects: deepClone(objs) }; }

        function duplicateSlideAt(i) {
            if (!Array.isArray(deck.slides)) deck.slides = [];
            const src = deck.slides[i];
            if (!src) return;

            const copy = deepClone(src);
            copy.id = uuidv4();
            copy.title = (src.title || `Slide ${i + 1}`) + ' (copy)';
            if (!Array.isArray(copy.objects)) copy.objects = [];
            copy.objects.forEach(o => { o.id = uuidv4(); });

            deck.slides.splice(i + 1, 0, copy);
            currentIndex = i + 1;

            renderAll();
            pushHistory();
            saveNow();
        }

        function copySelected() {
            const items = getSelectedObjects();
            if (!items.length) return;
            const payload = asClipboardPayload(items);
            appClipboard = payload;
            if (navigator.clipboard?.writeText) navigator.clipboard.writeText(JSON.stringify(payload)).catch(() => {});
        }

        document.getElementById('dupe').addEventListener('click', () => {
            if (currentIndex < 0) currentIndex = 0;
            if (currentIndex >= deck.slides.length) currentIndex = deck.slides.length - 1;
            duplicateSlideAt(currentIndex);
        });

        function cutSelected() {
            const s = currentSlide();
            const items = getSelectedObjects();
            if (!items.length) return;
            copySelected();
            s.objects = s.objects.filter(o => !selection.includes(o.id));
            selection = [];
            renderCanvas(); pushHistory(); postSave();
        }

        function pasteObjectsAt(objs, anchorX, anchorY) {
            const s = currentSlide();
            const minX = Math.min(...objs.map(o => o.x)), minY = Math.min(...objs.map(o => o.y));
            lastPasteBump = (lastPasteBump + PASTE_BUMP_STEP) % 80;
            const ax = (anchorX ?? 200) + lastPasteBump;
            const ay = (anchorY ?? 150) + lastPasteBump;
            const stageW = 960, stageH = 540;

            const newIds = [];
            objs.forEach(o => {
                const c = deepClone(o); c.id = uuidv4();
                const offX = o.x - minX, offY = o.y - minY;
                c.x = clamp(Math.round(ax + offX), 0, stageW - Math.max(5, o.width));
                c.y = clamp(Math.round(ay + offY), 0, stageH - Math.max(5, o.height));
                s.objects.push(c); newIds.push(c.id);
            });
            selection = newIds;
            renderCanvas(); pushHistory(); postSave();
        }

        async function pasteFromClipboard() {
            let payload = null;
            try {
                if (navigator.clipboard?.readText) {
                    const txt = await navigator.clipboard.readText();
                    if (txt) {
                        const p = JSON.parse(txt);
                        if (p?.type === 'realtime-slides' && Array.isArray(p.objects)) payload = p;
                    }
                }
            } catch (_) {}
            if (!payload && appClipboard) payload = appClipboard;
            if (!payload) return;
            pasteObjectsAt(payload.objects, lastMouse.x, lastMouse.y);
        }

        // ---------------------- Socket / Sync ----------------------
        const socket = io();
        socket.on('connect', () => { socket.emit('join_deck', { deck_id: deckId }); });

        socket.off('deck_state');
        let loadedOnce = false;
        let pendingEchoes = 0;
        let isPresenting = false;

        socket.on('deck_state', (serverDeck) => {
            const v = Number(serverDeck.version || 0);
            if (v <= serverVersion) return;
            serverVersion = v;

            if (!loadedOnce) {
                loadedOnce = true;
                isApplyingRemote = true;
                deck = serverDeck;
                history = []; historyIndex = -1;
                isApplyingRemote = false;
                if (isPresenting) renderPresentation(); else renderAll();
                setSaved('Loaded v' + serverVersion);
                return;
            }

            if (pendingEchoes > 0) {
                pendingEchoes--;
                setSaved('Saved v' + serverVersion);
                return;
            }

            isApplyingRemote = true;
            deck = serverDeck;
            isApplyingRemote = false;
            if (isPresenting) renderPresentation(); else renderAll();
            setSaved('Synced v' + serverVersion);
        });

        function currentSlide() { return deck.slides[currentIndex]; }
        function ensureSlide() {
            if (!deck.slides.length) {
                deck.slides.push({ id: uuidv4(), title: 'Slide 1', background: '#ffffff', objects: [] });
            }
        }
        function setSaving() { $('#saveState').textContent = 'Savingâ€¦'; }
        function setSaved(msg) { $('#saveState').textContent = msg || 'Saved'; }

        let postSave = debounce(() => {
            setSaving();
            pendingEchoes++;
            socket.emit('content_update', { deck_id: deck.id, title: deck.title, slides: deck.slides });
            setSaved('Saved');
        }, 250);

        function saveNow() {
            pendingEchoes++;
            socket.emit('content_update', { deck_id: deck.id, title: deck.title, slides: deck.slides });
            setSaved('Saved');
        }

        // ---------------------- Tooling ----------------------
        let tool = 'select';
        const toolButtons = {
            select: $('#tool-select'),
            rect: $('#tool-rect'),
            ellipse: $('#tool-ellipse'),
            text: $('#tool-text')
        };
        Object.entries(toolButtons).forEach(([k, btn]) => btn.onclick = () => setTool(k));
        function setTool(next) {
            tool = next;
            Object.entries(toolButtons).forEach(([k, btn]) => btn.classList.toggle('active', k === tool));
        }
        setTool('select');

        // Inspector controls
        const bgInput = $('#bg-color');
        const colorInput = $('#color');
        const fontInput = $('#fontSize');

        bgInput.addEventListener('input', (e) => {
            currentSlide().background = e.target.value;
            renderCanvas(); pushHistory(); postSave();
        });

        colorInput.addEventListener('input', (e) => {
            if (!selection.length) return;
            const slide = currentSlide();
            const val = e.target.value;
            selection.forEach(id => {
                const o = slide.objects.find(oo => oo.id === id);
                if (!o) return;
                if (o.type === 'text') o.color = val;
                else if (o.type !== 'image') o.fill = val;
            });
            renderCanvas();
            postSave();
        });
        colorInput.addEventListener('change', () => { pushHistory(); });

        function setFontSize(px) {
            const slide = currentSlide(); let changed = false;
            selection.forEach(id => {
                const o = slide.objects.find(oo => oo.id === id);
                if (o && o.type === 'text') { o.fontSize = px; changed = true; }
            });
            if (changed) { renderCanvas(); postSave(); }
        }
        fontInput.addEventListener('input', (e) => {
            const size = clampInt(e.target.value, 8, 200, 32);
            setFontSize(size);
        });
        fontInput.addEventListener('change', (e) => {
            const size = clampInt(e.target.value, 8, 200, 32);
            setFontSize(size); pushHistory();
        });

        function clampInt(v, min, max, fallback) {
            const n = parseInt(v, 10); if (Number.isFinite(n)) return Math.max(min, Math.min(max, n));
            return fallback;
        }

        function updateInspector() {
            const slide = currentSlide();
            const first = slide.objects.find(o => selection.includes(o.id));
            bgInput.value = slide.background || '#ffffff';

            const isText = !!(first && first.type === 'text');
            colorInput.value = first
                ? (first.type === 'text' ? (first.color || '#111111')
                    : first.type === 'image' ? '#111111' : (first.fill || '#8b5cf6'))
                : colorInput.value;

            fontInput.disabled = !isText;
            if (isText) fontInput.value = first.fontSize || 24;

            const enable = (btn, on) => { btn.disabled = !on; btn.style.opacity = on ? '1' : '.5'; };
            enable(document.getElementById('alignLeft'), isText);
            enable(document.getElementById('alignCenter'), isText);
            enable(document.getElementById('alignRight'), isText);
        }

        // ---------------------- Stage Rendering ----------------------
        const stage = $('#stage');

        stage.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return; // left button only
            const rect = stage.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            lastMouse = { x, y };

            if (e.target === stage && tool === 'select') {
                marquee = { x0: x, y0: y, x1: x, y1: y };
                renderCanvas();
                return;
            }

            if (tool !== 'select' && e.target === stage) {
                creatingObj = {
                    id: uuidv4(), type: tool, x, y, width: 1, height: 1,
                    fill: tool === 'text' ? 'transparent' : '#8b5cf6',
                    stroke: '#0f172a', rotation: 0,
                    text: tool === 'text' ? 'Text' : undefined,
                    fontSize: 24, fontFamily: 'system-ui, Segoe UI, Roboto, sans-serif',
                    color: '#111111'
                };
                renderCanvas();
            }
        });

        window.addEventListener('mousemove', (e) => {
            const rect = stage.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            lastMouse = { x, y };

            if (creatingObj) {
                creatingObj.width = (x - creatingObj.x);
                creatingObj.height = (y - creatingObj.y);
                renderCanvas();
            }
            if (dragState) {
                const slide = currentSlide();
                dragState.ids.forEach(id => {
                    const o = slide.objects.find(oo => oo.id === id);
                    const off = dragState.offsets[id];
                    o.x = x - off.dx; o.y = y - off.dy;
                });
                renderCanvas();
            }
            if (marquee) {
                marquee.x1 = x; marquee.y1 = y;
                renderCanvas();
            }
        });

        window.addEventListener('mouseup', () => {
            if (creatingObj) {
                const slide = currentSlide();
                if (creatingObj.width < 0) { creatingObj.x += creatingObj.width; creatingObj.width = Math.abs(creatingObj.width); }
                if (creatingObj.height < 0) { creatingObj.y += creatingObj.height; creatingObj.height = Math.abs(creatingObj.height); }
                slide.objects.push(creatingObj);
                selection = [creatingObj.id];
                renderCanvas(); pushHistory(); postSave();
                if (creatingObj.type === 'text') {
                    setTimeout(() => { const el = document.getElementById('obj-' + creatingObj.id); if (el) { el.focus(); selectAllText(el); } }, 0);
                }
                creatingObj = null;
            }
            if (dragState) { pushHistory(); postSave(); dragState = null; }
            if (marquee) {
                const slide = currentSlide();
                const box = normRect(marquee);
                selection = slide.objects.filter(o => intersects(box, { x: o.x, y: o.y, width: o.width, height: o.height })).map(o => o.id);
                marquee = null; renderCanvas(); updateInspector();
            }
        });

        function normRect(r) { const x = Math.min(r.x0, r.x1), y = Math.min(r.y0, r.y1); return { x, y, width: Math.abs(r.x1 - r.x0), height: Math.abs(r.y1 - r.y0) }; }
        function intersects(a, b) { return !(a.x > b.x + b.width || a.x + a.width < b.x || a.y > b.y + b.height || a.y + a.height < b.y); }
        function selectAllText(el) { const range = document.createRange(); range.selectNodeContents(el); const sel = window.getSelection(); sel.removeAllRanges(); sel.addRange(range); }

        function renderCanvas() {
            ensureSlide();
            const slide = currentSlide();
            stage.style.background = slide.background || '#ffffff';
            stage.innerHTML = '';

            slide.objects.forEach(o => {
                const el = document.createElement('div');
                el.id = 'obj-' + o.id;
                el.className = 'obj' + (selection.includes(o.id) ? ' selected' : '');
                el.style.left = o.x + 'px';
                el.style.top = o.y + 'px';
                el.style.width = o.width + 'px';
                el.style.height = o.height + 'px';
                el.style.transform = `rotate(${o.rotation || 0}deg)`;

                if (o.type === 'rect') {
                    el.style.background = o.fill || '#ddd';
                    el.style.border = '1px solid ' + (o.stroke || 'transparent');
                } else if (o.type === 'ellipse') {
                    el.style.background = o.fill || '#ddd';
                    el.style.border = '1px solid ' + (o.stroke || 'transparent');
                    el.style.borderRadius = '999px';
                } else if (o.type === 'text') {
                    el.contentEditable = true;
                    el.style.color = o.color || '#111111';
                    el.style.fontSize = (o.fontSize || 24) + 'px';
                    el.style.fontFamily = o.fontFamily || 'system-ui, Segoe UI, Roboto, sans-serif';
                    el.style.whiteSpace = 'pre-wrap';
                    applyTextAlignStyles(el, o.align);
                    el.innerText = o.text || '';
                    el.addEventListener('input', () => { o.text = el.innerText; postSave(); });
                    el.addEventListener('dblclick', () => { el.focus(); selectAllText(el); });
                } else if (o.type === 'image') {
                    const img = new Image();
                    img.src = o.dataUrl; // base64 data URL
                    img.draggable = false;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    el.appendChild(img);
                }

                // select/drag (single-click to drag, double-click to edit text)
                el.onmousedown = (e) => {
                    if (tool !== 'select') return;
                    e.stopPropagation();
                    // Prevent text focus on single-click so drag works reliably
                    if (o.type === 'text' && e.detail < 2) e.preventDefault();

                    const already = selection.includes(o.id);
                    if (e.shiftKey) selection = already ? selection.filter(id => id !== o.id) : [...selection, o.id];
                    else selection = already ? selection : [o.id];

                    const rect = stage.getBoundingClientRect();
                    const x = e.clientX - rect.left, y = e.clientY - rect.top;
                    const ids = selection.slice();
                    const offsets = {};
                    ids.forEach(id => {
                        const obj = slide.objects.find(oo => oo.id === id);
                        offsets[id] = { dx: x - obj.x, dy: y - obj.y };
                    });
                    dragState = { ids, offsets };
                    updateInspector();
                    renderCanvas();
                };

                // resize handle
                if (selection.includes(o.id)) {
                    const h = document.createElement('div');
                    h.className = 'handle';
                    h.style.position = 'absolute';
                    h.style.right = '-6px'; h.style.bottom = '-6px';
                    h.style.width = '12px'; h.style.height = '12px';
                    h.style.cursor = 'se-resize';
                    h.onmousedown = (e) => {
                        e.stopPropagation();
                        const rect = stage.getBoundingClientRect();
                        const sx = e.clientX - rect.left, sy = e.clientY - rect.top;
                        const sw = o.width, sh = o.height;
                        const move = (ev) => {
                            const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
                            o.width = Math.max(5, sw + (x - sx));
                            o.height = Math.max(5, sh + (y - sy));
                            renderCanvas();
                        };
                        const up = () => {
                            window.removeEventListener('mousemove', move);
                            window.removeEventListener('mouseup', up);
                            pushHistory(); postSave();
                        };
                        window.addEventListener('mousemove', move);
                        window.addEventListener('mouseup', up);
                    };
                    el.appendChild(h);
                }

                stage.appendChild(el);
            });

            if (marquee) {
                const m = normRect(marquee);
                const mx = document.createElement('div');
                mx.className = 'marquee';
                mx.style.left = m.x + 'px';
                mx.style.top = m.y + 'px';
                mx.style.width = m.width + 'px';
                mx.style.height = m.height + 'px';
                stage.appendChild(mx);
            }
        }

        // ---------------------- Slides list (with drag-reorder) ----------------------
        function moveItem(arr, from, to) {
            if (from === to || from < 0 || to < 0 || from >= arr.length || to >= arr.length) return arr;
            const item = arr.splice(from, 1)[0];
            arr.splice(to, 0, item);
            return arr;
        }

        function renderSlidesList() {
            const cont = $('#slides');
            cont.innerHTML = '';
            deck.slides.forEach((s, i) => {
                const row = document.createElement('div');
                row.className = 'slide-item' + (i === currentIndex ? ' active' : '');
                row.onclick = () => { currentIndex = i; selection = []; renderAll(); };
                row.setAttribute('data-index', String(i));
                row.draggable = true;

                // DnD handlers
                row.addEventListener('dragstart', (ev) => {
                    ev.dataTransfer.setData('text/plain', String(i));
                    ev.dataTransfer.effectAllowed = 'move';
                });
                row.addEventListener('dragover', (ev) => { ev.preventDefault(); row.classList.add('drag-over'); });
                row.addEventListener('dragleave', () => { row.classList.remove('drag-over'); });
                row.addEventListener('drop', (ev) => {
                    ev.preventDefault();
                    row.classList.remove('drag-over');
                    const from = parseInt(ev.dataTransfer.getData('text/plain'), 10);
                    const to = i;
                    if (!Number.isFinite(from)) return;
                    moveItem(deck.slides, from, to);
                    currentIndex = to;
                    renderSlidesList();
                    pushHistory(); postSave();
                });

                const num = document.createElement('div'); num.className = 'n'; num.textContent = i + 1;

                const name = document.createElement('input');
                name.value = s.title || `Slide ${i + 1}`;
                name.onmousedown = ev => ev.stopPropagation();
                name.oninput = () => { s.title = name.value; pushHistory(); postSave(); };

                const dup = document.createElement('button');
                dup.textContent = 'âŽ˜';
                dup.title = 'Duplicate';
                dup.className = 'btn';
                dup.onclick = (ev) => { ev.stopPropagation(); duplicateSlideAt(i); };

                const del = document.createElement('button'); del.textContent = 'ðŸ—‘'; del.title = 'Delete'; del.className = 'btn';
                del.onclick = (ev) => {
                    ev.stopPropagation();
                    if (deck.slides.length === 1) return;
                    deck.slides.splice(i, 1);
                    currentIndex = Math.max(0, Math.min(currentIndex, deck.slides.length - 1));
                    pushHistory(); renderAll(); postSave();
                };

                row.appendChild(num);
                row.appendChild(name);
                row.appendChild(dup);
                row.appendChild(del);
                cont.appendChild(row);
            });
        }

        function renderAll() {
            $('#deckTitle').value = deck.title || 'Untitled deck';
            if (currentIndex >= deck.slides.length) currentIndex = deck.slides.length - 1;
            if (currentIndex < 0) currentIndex = 0;
            renderSlidesList();
            renderCanvas();
            updateInspector();
            updateUndoRedoUI();
        }

        // ---------------------- UI actions ----------------------
        $('#deckTitle').addEventListener('input', (e) => { deck.title = e.target.value; pushHistory(); renderSlidesList(); postSave(); });
        $('#addSlide').addEventListener('click', () => {
            const n = deck.slides.length + 1;
            deck.slides.push({ id: uuidv4(), title: 'Slide ' + n, background: '#ffffff', objects: [] });
            currentIndex = deck.slides.length - 1; pushHistory(); renderAll(); postSave();
        });
        $('#delSlide').addEventListener('click', () => {
            if (deck.slides.length === 1) return;
            deck.slides.splice(currentIndex, 1);
            currentIndex = Math.max(0, currentIndex - 1); pushHistory(); renderAll(); postSave();
        });
        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('redoBtn').addEventListener('click', redo);

        // Keyboard: delete/nudge/undo/redo
        window.addEventListener('keydown', (e) => {
            const isMod = e.ctrlKey || e.metaKey;
            const key = (e.key || '').toLowerCase();

            if (isMod && key === 'z') { e.preventDefault(); if (e.shiftKey) redo(); else undo(); return; }
            if (isMod && key === 'y') { e.preventDefault(); redo(); return; }

            if (isMod && key === 'c' && selection.length) {
                if (activelySelectingText()) return;
                e.preventDefault(); copySelected(); return;
            }
            if (isMod && key === 'x' && selection.length) {
                if (activelySelectingText()) return;
                e.preventDefault(); cutSelected(); return;
            }
            if (isMod && key === 'v') {
                if (activelySelectingText()) return;
                e.preventDefault(); pasteFromClipboard(); return;
            }

            if ((key === 'delete' || key === 'backspace') && selection.length) {
                const slide = currentSlide();
                slide.objects = slide.objects.filter(o => !selection.includes(o.id));
                selection = [];
                renderCanvas(); pushHistory(); postSave();
                return;
            }

            if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(key) && selection.length) {
                const slide = currentSlide();
                const d = e.shiftKey ? 10 : 1;
                selection.forEach(id => {
                    const o = slide.objects.find(oo => oo.id === id);
                    if (!o) return;
                    if (key === 'arrowup') o.y -= d;
                    if (key === 'arrowdown') o.y += d;
                    if (key === 'arrowleft') o.x -= d;
                    if (key === 'arrowright') o.x += d;
                });
                renderCanvas(); pushHistory(); postSave();
            }
        });

        window.addEventListener('paste', (e) => {
            if (activelySelectingText()) return;
            const txt = e.clipboardData?.getData('text/plain');
            if (!txt) return;
            try {
                const p = JSON.parse(txt);
                if (p?.type === 'realtime-slides' && Array.isArray(p.objects)) {
                    e.preventDefault();
                    pasteObjectsAt(p.objects, lastMouse.x, lastMouse.y);
                }
            } catch (_) {}
        });

        // ---------------------- Images: Paste & Drag/Drop ----------------------
        stage.addEventListener('paste', (e) => {
            const items = (e.clipboardData || window.clipboardData)?.items || [];
            for (const it of items) {
                if (it.type && it.type.indexOf('image') === 0) {
                    const file = it.getAsFile();
                    if (file) { e.preventDefault(); handleImageFile(file, lastMouse.x, lastMouse.y); }
                }
            }
        });

        stage.addEventListener('dragover', (e) => { e.preventDefault(); });
        stage.addEventListener('drop', (e) => {
            e.preventDefault();
            const rect = stage.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            const files = e.dataTransfer.files || [];
            for (const file of files) {
                if (file.type && file.type.startsWith('image/')) {
                    handleImageFile(file, x, y);
                }
            }
        });

        function activelySelectingText() {
            const el = document.activeElement;
            if (!el || !el.isContentEditable) return false;
            const sel = window.getSelection?.();
            return sel && !sel.isCollapsed;
        }

        function handleImageFile(file, x, y) {
            const reader = new FileReader();
            reader.onload = () => {
                const dataUrl = reader.result;
                const img = new Image();
                img.onload = () => {
                    const maxW = 600, maxH = 400;
                    let w = img.naturalWidth, h = img.naturalHeight;
                    const scale = Math.min(1, maxW / w, maxH / h);
                    w = Math.max(40, Math.round(w * scale));
                    h = Math.max(40, Math.round(h * scale));
                    const slide = currentSlide();
                    const o = {
                        id: uuidv4(), type: 'image',
                        x: Math.max(0, Math.min((x || 200) - w / 2, 960 - w)),
                        y: Math.max(0, Math.min((y || 150) - h / 2, 540 - h)),
                        width: w, height: h, rotation: 0,
                        dataUrl: dataUrl,
                    };
                    slide.objects.push(o);
                    selection = [o.id];
                    renderCanvas(); pushHistory(); postSave();
                };
                img.src = dataUrl;
            };
            reader.readAsDataURL(file);
        }

        // ---------------------- Presentation Mode ----------------------
        const presentBtn = document.getElementById('presentBtn');
        presentBtn.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                stage.classList.add('presenting');
                stage.requestFullscreen().then(() => {
                    isPresenting = true;
                    renderPresentation();
                    updatePresentScale();
                }).catch(console.error);
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (!document.fullscreenElement) {
                isPresenting = false;
                stage.classList.remove('presenting');
                stage.style.transform = '';
                window.removeEventListener('resize', updatePresentScale);
                renderAll();
            } else {
                window.addEventListener('resize', updatePresentScale);
            }
        });

        function updatePresentScale() {
            if (!isPresenting) return;
            const sw = window.innerWidth;
            const sh = window.innerHeight;
            const scale = Math.min(sw / 960, sh / 540);
            stage.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }

        function renderPresentation() {
            if (!isPresenting) return;
            ensureSlide();
            const slide = currentSlide();
            stage.style.background = slide.background || '#ffffff';
            stage.innerHTML = '';

            slide.objects.forEach(o => {
                const el = document.createElement('div');
                el.style.position = 'absolute';
                el.style.left = o.x + 'px';
                el.style.top = o.y + 'px';
                el.style.width = o.width + 'px';
                el.style.height = o.height + 'px';
                el.style.transform = `rotate(${o.rotation || 0}deg)`;

                if (o.type === 'rect') {
                    el.style.background = o.fill || '#ddd';
                } else if (o.type === 'ellipse') {
                    el.style.background = o.fill || '#ddd';
                    el.style.borderRadius = '999px';
                } else if (o.type === 'text') {
                    el.style.color = o.color || '#111111';
                    el.style.fontSize = (o.fontSize || 24) + 'px';
                    el.style.fontFamily = o.fontFamily || 'system-ui, Segoe UI, Roboto, sans-serif';
                    el.style.whiteSpace = 'pre-wrap';
                    applyTextAlignStyles(el, o.align);
                    el.innerText = o.text || '';
                } else if (o.type === 'image') {
                    const img = new Image();
                    img.src = o.dataUrl;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    el.appendChild(img);
                }
                stage.appendChild(el);
            });
            updatePresentScale();
        }

        // Keyboard nav while presenting
        window.addEventListener('keydown', (e) => {
            if (!isPresenting) return;
            if (e.key === 'ArrowRight') {
                currentIndex = Math.min(deck.slides.length - 1, currentIndex + 1);
                renderPresentation();
            } else if (e.key === 'ArrowLeft') {
                currentIndex = Math.max(0, currentIndex - 1);
                renderPresentation();
            } else if (e.key === 'Escape' && document.fullscreenElement) {
                document.exitFullscreen();
            }
        });

        // ---------------------- Text Align ----------------------
        function setTextAlign(al) {
            const slide = currentSlide();
            let changed = false;
            selection.forEach(id => {
                const o = slide.objects.find(oo => oo.id === id);
                if (o && o.type === 'text') { o.align = al; changed = true; }
            });
            if (changed) { renderCanvas(); pushHistory(); postSave(); }
        }
        const alignLeftBtn   = document.getElementById('alignLeft');
        const alignCenterBtn = document.getElementById('alignCenter');
        const alignRightBtn  = document.getElementById('alignRight');
        alignLeftBtn.onclick   = () => setTextAlign('left');
        alignCenterBtn.onclick = () => setTextAlign('center');
        alignRightBtn.onclick  = () => setTextAlign('right');

        function applyTextAlignStyles(el, align) {
            const a = align || 'center';
            el.style.textAlign = a;
            el.style.display = 'flex';
            el.style.alignItems = 'center';
            el.style.justifyContent =
                a === 'left' ? 'flex-start' : a === 'right' ? 'flex-end' : 'center';
            el.style.padding = '4px';
        }

        
        const hamburger = document.getElementById('hamburger');
        hamburger.addEventListener('click', () => {
            document.querySelector('.app').classList.toggle('collapsed');
            document.querySelector('.side').classList.toggle('collapsed');
        });

        // Initial render
        renderAll();
    </script>
</body>

</html>
